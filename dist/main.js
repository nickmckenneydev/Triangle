(()=>{"use strict";const e="struct TransformData {\r\n    model: mat4x4<f32>,\r\n    view: mat4x4<f32>,\r\n    projection: mat4x4<f32>,\r\n};\r\n@binding(0) @group(0) var<uniform> transformUBO: TransformData;//Uniform buffer declared\r\n\r\nstruct Fragment {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) Color : vec4<f32>\r\n};\r\n\r\n@vertex\r\nfn vs_main(@location(0) vertexPostion: vec3<f32>, @location(1) vertexColor: vec3<f32>) -> Fragment {\r\n\r\n    var output : Fragment;\r\n    //                       Depth     |    Sets it from world coord to view| Transforms Model coords to world\r\n    // Takes a vertex local position and calcs it final position\r\n    \r\n    output.Position = transformUBO.projection * transformUBO.view * transformUBO.model * vec4<f32>(vertexPostion, 1.0);\r\n    output.Color = vec4<f32>(vertexColor, 1.0);\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fs_main(@location(0) Color: vec4<f32>) -> @location(0) vec4<f32> {\r\n    return Color;\r\n}";class t{constructor(e){const t=new Float32Array([0,0,.5,1,0,0,0,-.5,-.5,0,1,0,0,.5,-.5,0,0,1]),r=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,i={size:t.byteLength,usage:r,mappedAtCreation:!0};this.buffer=e.createBuffer(i),new Float32Array(this.buffer.getMappedRange()).set(t),this.buffer.unmap(),this.bufferLayout={arrayStride:24,attributes:[{shaderLocation:0,format:"float32x3",offset:0},{shaderLocation:1,format:"float32x3",offset:12}]}}}var r=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;function n(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.PI;var o=function(e,t,r,i){return new(r||(r=Promise))(function(n,o){function a(e){try{u(i.next(e))}catch(e){o(e)}}function s(e){try{u(i.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r(function(e){e(t)})).then(a,s)}u((i=i.apply(e,t||[])).next())})};class a{constructor(e){this.t=0,this.canvas=e,this.t=0}static create(e){return o(this,void 0,void 0,function*(){const t=new a(e);return yield t.Initialize(),t})}Initialize(){return o(this,void 0,void 0,function*(){yield this.setupDevice(),this.createAssets(),yield this.makePipeline(),this.render()})}setupDevice(){return o(this,void 0,void 0,function*(){var e,t;this.adapter=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),this.device=yield null===(t=this.adapter)||void 0===t?void 0:t.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})})}makePipeline(){return o(this,void 0,void 0,function*(){this.uniformBuffer=this.device.createBuffer({size:192,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const t=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.bindGroup=this.device.createBindGroup({layout:t,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]});const r=this.device.createPipelineLayout({bindGroupLayouts:[t]});this.pipeline=this.device.createRenderPipeline({vertex:{module:this.device.createShaderModule({code:e}),entryPoint:"vs_main",buffers:[this.triangleMesh.bufferLayout]},fragment:{module:this.device.createShaderModule({code:e}),entryPoint:"fs_main",targets:[{format:this.format}]},primitive:{topology:"triangle-list"},layout:r})})}createAssets(){this.triangleMesh=new t(this.device)}render(){this.t+=.1,this.t>2*Math.PI&&(this.t-=2*Math.PI);const e=n();!function(e,t,r,i,n){var o=1/Math.tan(t/2);if(e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=n&&n!==1/0){var a=1/(i-n);e[10]=(n+i)*a,e[14]=2*n*i*a}else e[10]=-1,e[14]=-2*i}(e,Math.PI/4,800/600,.1,10);const t=n();var i,o,a,s,u,c,f,h,d,l,v,m,p,y,g,P,M,b,w,x,B,A,U;i=t,g=(o=[-2,0,2])[0],P=o[1],M=o[2],b=(s=[0,0,1])[0],w=s[1],x=s[2],B=(a=[0,0,0])[0],A=a[1],U=a[2],Math.abs(g-B)<r&&Math.abs(P-A)<r&&Math.abs(M-U)<r?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(i):(v=g-B,m=P-A,p=M-U,u=w*(p*=y=1/Math.sqrt(v*v+m*m+p*p))-x*(m*=y),c=x*(v*=y)-b*p,f=b*m-w*v,(y=Math.sqrt(u*u+c*c+f*f))?(u*=y=1/y,c*=y,f*=y):(u=0,c=0,f=0),h=m*f-p*c,d=p*u-v*f,l=v*c-m*u,(y=Math.sqrt(h*h+d*d+l*l))?(h*=y=1/y,d*=y,l*=y):(h=0,d=0,l=0),i[0]=u,i[1]=h,i[2]=v,i[3]=0,i[4]=c,i[5]=d,i[6]=m,i[7]=0,i[8]=f,i[9]=l,i[10]=p,i[11]=0,i[12]=-(u*g+c*P+f*M),i[13]=-(h*g+d*P+l*M),i[14]=-(v*g+m*P+p*M),i[15]=1);const F=n();!function(e,t,i,n){var o,a,s,u,c,f,h,d,l,v,m,p,y,g,P,M,b,w,x,B,A,U,F,q,O=n[0],C=n[1],G=n[2],I=Math.sqrt(O*O+C*C+G*G);I<r||(O*=I=1/I,C*=I,G*=I,o=Math.sin(i),s=1-(a=Math.cos(i)),u=t[0],c=t[1],f=t[2],h=t[3],d=t[4],l=t[5],v=t[6],m=t[7],p=t[8],y=t[9],g=t[10],P=t[11],M=O*O*s+a,b=C*O*s+G*o,w=G*O*s-C*o,x=O*C*s-G*o,B=C*C*s+a,A=G*C*s+O*o,U=O*G*s+C*o,F=C*G*s-O*o,q=G*G*s+a,e[0]=u*M+d*b+p*w,e[1]=c*M+l*b+y*w,e[2]=f*M+v*b+g*w,e[3]=h*M+m*b+P*w,e[4]=u*x+d*B+p*A,e[5]=c*x+l*B+y*A,e[6]=f*x+v*B+g*A,e[7]=h*x+m*B+P*A,e[8]=u*U+d*F+p*q,e[9]=c*U+l*F+y*q,e[10]=f*U+v*F+g*q,e[11]=h*U+m*F+P*q,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]))}(F,F,this.t,[0,0,1]),this.device.queue.writeBuffer(this.uniformBuffer,0,new Float32Array(F)),this.device.queue.writeBuffer(this.uniformBuffer,64,new Float32Array(t)),this.device.queue.writeBuffer(this.uniformBuffer,128,new Float32Array(e));const q=this.device.createCommandEncoder(),O=this.context.getCurrentTexture().createView(),C=q.beginRenderPass({colorAttachments:[{view:O,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});C.setPipeline(this.pipeline),C.setVertexBuffer(0,this.triangleMesh.buffer),C.setBindGroup(0,this.bindGroup),C.draw(3,1,0,0),C.end(),this.device.queue.submit([q.finish()])}}!function(){var e,t,r,i;e=this,t=void 0,i=function*(){const e=document.getElementById("gfx-main");if(!e)return console.log("WOMP WOMP"),1;try{const t=yield a.create(e);function r(){t.render(),requestAnimationFrame(r)}requestAnimationFrame(r)}catch(i){console.error("WOMP WOMP",i)}},new((r=void 0)||(r=Promise))(function(n,o){function a(e){try{u(i.next(e))}catch(e){o(e)}}function s(e){try{u(i.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r(function(e){e(t)})).then(a,s)}u((i=i.apply(e,t||[])).next())})}()})();